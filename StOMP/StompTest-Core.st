TestCase subclass: #StompCustomSerializationTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompCustomSerializationTestCase methodsFor: 'testing' stamp: 'mu 5/10/2011 12:22'!testReadStompWriteValueAndStompReadValue	"self debug: #testReadStompWriteValueAndStompReadValue"	| object1 object2 stomp1 docodedTuple className array stomp2 readArray inArray readObject1 readObject2 |	object1 := StompMockCustomWriteObject new.	object1 name: 'Masashi Umezawa'.	object1 email: 'mu@example.com'.		object2 := StompMockCustomWriteObject new.	object2 name: 'Shiho Umezawa'.	object2 email: 'su@example.com'.		stomp1 := object1 toStomp.	docodedTuple := MpDecoder decode: stomp1.	className := ((docodedTuple at: 2) at: StompConstants klassName) asString asSymbol.	self should: [className = #StompMockMementoArray].	array := Array with: object1 with: object2 with: (Array with: object1 with: object2 with: 3).	stomp2 := array toStomp.		readArray := Object fromStomp: stomp2.	inArray := readArray at: 3.	self should: [(readArray at: 1) = (inArray at: 1)].	self should: [(readArray at: 2) = (inArray at: 2)].	self shouldnt: [(readArray at: 3) = (Array with: object1 with: object2 with: 3)].		readObject1 := readArray at: 1.	self should: [readObject1 name = 'Masashi Umezawa'].		self should: [readObject1 email = 'mu@example.com'].	readObject2 := readArray at: 2.	self should: [readObject2 name = 'Shiho Umezawa'].		self should: [readObject2 email = 'su@example.com']! !!StompCustomSerializationTestCase methodsFor: 'testing' stamp: 'mu 3/8/2011 00:37'!testSameStompWriteValueAndStompReadValue	"self debug: #testSameStompWriteValueAndStompReadValue"	| obj1 array array2 |	obj1 := StompMockCustomWriteObject new name: 'AA'; email: 'aa@example.com'.	array := Array with: obj1 with: obj1.	array2 := Object fromStomp: array toStomp.	self should: [(array2 at: 1) = (array2 at: 2)].! !!StompCustomSerializationTestCase methodsFor: 'testing' stamp: 'mu 3/6/2011 13:40'!testStompInitialize	"self debug: #testStompInitialize"	| obj readObject|	obj := StompMockObjectInitializingOnRead new.	obj instVar1: 'cache1'.	obj instVar2: 'cache2'.	obj instVar3: 3.		obj instVar4: 4.	obj instVar5: 5.	readObject := StompReader decode: (StompWriter encode: obj).	self should: [readObject instVar1 = 'stomp initialized 1'].		self should: [readObject instVar2 = 'stomp initialized 2'].		self should: [readObject instVar3 = 3].		self should: [readObject instVar4 = 4].	self should: [readObject instVar5 = 5].		self should: [obj instVar1 = 'cache1'].		self should: [obj instVar2 = 'cache2'].		self should: [obj instVar3 = 3].		self should: [obj instVar4 = 4].	self should: [obj instVar5 = 5].! !!StompCustomSerializationTestCase methodsFor: 'testing' stamp: 'mu 3/6/2011 13:41'!testStompPrepareWrite	"self debug: #testStompPrepareWrite"	| obj readObject|	obj := StompMockObjectPreparingOnWrite new.	obj instVar1: 1.	obj instVar2: 2.	obj instVar3: 3.		obj instVar4: 4.	obj instVar5: 5.	readObject := StompReader decode: (StompWriter encode: obj).	self should: [readObject instVar1 = '1'].		self should: [readObject instVar2 = 4].		self should: [readObject instVar3 = 3].		self should: [readObject instVar4 = 4].	self should: [readObject instVar5 = 5].		self should: [obj instVar1 = '1'].		self should: [obj instVar2 = 4].		self should: [obj instVar3 = 3].		self should: [obj instVar4 = 4].	self should: [obj instVar5 = 5].	! !!StompCustomSerializationTestCase methodsFor: 'testing' stamp: 'mu 3/6/2011 13:41'!testStompTransientClassInstVarNames	"self debug: #testStompTransientClassInstVarNames"	| obj encodedBytes readObject|	obj := StompMockObjectWithCache.	obj att1: 1.	obj att2: 2.	obj cache1: 'cache1'.	encodedBytes := StompWriter encode: obj.		obj att1: nil.	obj att2: nil.	obj cache1: nil.	readObject := StompReader decode: encodedBytes.	self should: [readObject att1 = 1].		self should: [readObject att2 = 2].		self should: [readObject cache1 = nil].				! !!StompCustomSerializationTestCase methodsFor: 'testing' stamp: 'mu 3/6/2011 13:41'!testStompTransientInstVarNames	"self debug: #testStompTransientInstVarNames"	| obj readObject|	obj := StompMockObjectWithCache new.	obj instVar1: '1'.	obj instVar2: '2'.	obj instVar3: 3.		obj instVar4: 4.	obj instVar5: 5.	readObject := StompReader decode: (StompWriter encode: obj).	self should: [readObject instVar1 = nil].		self should: [readObject instVar2 = nil].		self should: [readObject instVar3 = nil].		self should: [readObject instVar4 = 4].	self should: [readObject instVar5 = 5].		self should: [obj instVar1 = '1'].		self should: [obj instVar2 = '2'].		self should: [obj instVar3 = 3].		self should: [obj instVar4 = 4].	self should: [obj instVar5 = 5].! !ByteArray variableByteSubclass: #StompMockByteArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!Object subclass: #StompMockCustomWriteObject	instanceVariableNames: 'name email'	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockCustomWriteObject methodsFor: 'accessing' stamp: 'mu 3/6/2011 14:04'!email	"Answer the value of email"	^ email! !!StompMockCustomWriteObject methodsFor: 'accessing' stamp: 'mu 3/6/2011 14:04'!email: anObject	"Set the value of email"	email := anObject! !!StompMockCustomWriteObject methodsFor: 'accessing' stamp: 'mu 3/6/2011 13:36'!name	^name! !!StompMockCustomWriteObject methodsFor: 'accessing' stamp: 'mu 3/6/2011 13:36'!name: anObject	"Set the value of name"	name := anObject! !!StompMockCustomWriteObject methodsFor: 'initialize-release' stamp: 'mu 3/6/2011 14:05'!initialize	name := 'Test Name'.	email := 'test-name@example.com'! !!StompMockCustomWriteObject methodsFor: 'stomp-objectstream-writing' stamp: 'mu 3/6/2011 14:04'!stompWriteValue	"Write myself as an array"	^StompMockMementoArray with: self name with: self email! !Object subclass: #StompMockFixedClass	instanceVariableNames: 'instVar1 instVar2 instVar3 instVar4 instVar5'	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockFixedClass methodsFor: 'comparing' stamp: 'mu 2/2/2011 23:57'!equals: other	self class = other class ifFalse: [^false].	instVar1 = other instVar1 ifFalse: [^false].	instVar2 = other instVar2 ifFalse: [^false].	instVar3 = other instVar3 ifFalse: [^false].	instVar4 = other instVar4 ifFalse: [^false].	instVar5 = other instVar5 ifFalse: [^false].	^true! !!StompMockFixedClass methodsFor: 'accessing' stamp: 'mu 12/19/2010 00:37'!instVar1	"Answer the value of instVar1"	^ instVar1! !!StompMockFixedClass methodsFor: 'accessing' stamp: 'mu 12/19/2010 00:37'!instVar1: anObject	"Set the value of instVar1"	instVar1 := anObject! !!StompMockFixedClass methodsFor: 'accessing' stamp: 'mu 12/19/2010 00:37'!instVar2	"Answer the value of instVar2"	^ instVar2! !!StompMockFixedClass methodsFor: 'accessing' stamp: 'mu 12/19/2010 00:37'!instVar2: anObject	"Set the value of instVar2"	instVar2 := anObject! !!StompMockFixedClass methodsFor: 'accessing' stamp: 'mu 12/19/2010 00:37'!instVar3	"Answer the value of instVar3"	^ instVar3! !!StompMockFixedClass methodsFor: 'accessing' stamp: 'mu 12/19/2010 00:37'!instVar3: anObject	"Set the value of instVar3"	instVar3 := anObject! !!StompMockFixedClass methodsFor: 'accessing' stamp: 'mu 12/19/2010 00:37'!instVar4	"Answer the value of instVar4"	^ instVar4! !!StompMockFixedClass methodsFor: 'accessing' stamp: 'mu 12/19/2010 00:37'!instVar4: anObject	"Set the value of instVar4"	instVar4 := anObject! !!StompMockFixedClass methodsFor: 'accessing' stamp: 'mu 12/19/2010 00:37'!instVar5	"Answer the value of instVar5"	^ instVar5! !!StompMockFixedClass methodsFor: 'accessing' stamp: 'mu 12/19/2010 00:37'!instVar5: anObject	"Set the value of instVar5"	instVar5 := anObject! !Object subclass: #StompMockFixedClass2	instanceVariableNames: 'instVar1 instVar2 instVar3 instVar4 instVar5'	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockFixedClass2 methodsFor: 'comparing' stamp: 'mu 4/25/2011 23:30'!equals: other	self class = other class ifFalse: [^false].	instVar1 = other instVar1 ifFalse: [^false].	instVar2 = other instVar2 ifFalse: [^false].	instVar3 = other instVar3 ifFalse: [^false].	instVar4 = other instVar4 ifFalse: [^false].	instVar5 = other instVar5 ifFalse: [^false].	^true! !!StompMockFixedClass2 methodsFor: 'accessing' stamp: 'mu 4/25/2011 23:30'!instVar1	"Answer the value of instVar1"	^ instVar1! !!StompMockFixedClass2 methodsFor: 'accessing' stamp: 'mu 4/25/2011 23:30'!instVar1: anObject	"Set the value of instVar1"	instVar1 := anObject! !!StompMockFixedClass2 methodsFor: 'accessing' stamp: 'mu 4/25/2011 23:30'!instVar2	"Answer the value of instVar2"	^ instVar2! !!StompMockFixedClass2 methodsFor: 'accessing' stamp: 'mu 4/25/2011 23:30'!instVar2: anObject	"Set the value of instVar2"	instVar2 := anObject! !!StompMockFixedClass2 methodsFor: 'accessing' stamp: 'mu 4/25/2011 23:30'!instVar3	"Answer the value of instVar3"	^ instVar3! !!StompMockFixedClass2 methodsFor: 'accessing' stamp: 'mu 4/25/2011 23:30'!instVar3: anObject	"Set the value of instVar3"	instVar3 := anObject! !!StompMockFixedClass2 methodsFor: 'accessing' stamp: 'mu 4/25/2011 23:30'!instVar4	"Answer the value of instVar4"	^ instVar4! !!StompMockFixedClass2 methodsFor: 'accessing' stamp: 'mu 4/25/2011 23:30'!instVar4: anObject	"Set the value of instVar4"	instVar4 := anObject! !!StompMockFixedClass2 methodsFor: 'accessing' stamp: 'mu 4/25/2011 23:30'!instVar5	"Answer the value of instVar5"	^ instVar5! !!StompMockFixedClass2 methodsFor: 'accessing' stamp: 'mu 4/25/2011 23:30'!instVar5: anObject	"Set the value of instVar5"	instVar5 := anObject! !Object subclass: #StompMockFixedNewFailedClass	instanceVariableNames: 'att1 att2 att3Block'	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockFixedNewFailedClass methodsFor: 'accessing' stamp: 'mu 4/26/2011 13:46'!att1	^att1! !!StompMockFixedNewFailedClass methodsFor: 'accessing' stamp: 'mu 4/26/2011 13:46'!att1: aValue	att1 := aValue! !!StompMockFixedNewFailedClass methodsFor: 'accessing' stamp: 'mu 4/26/2011 13:46'!att2	^att2! !!StompMockFixedNewFailedClass methodsFor: 'accessing' stamp: 'mu 4/26/2011 13:46'!att2: aValue	att2 := aValue! !!StompMockFixedNewFailedClass methodsFor: 'accessing' stamp: 'mu 4/26/2011 13:46'!att3Block	^att3Block! !!StompMockFixedNewFailedClass methodsFor: 'accessing' stamp: 'mu 4/26/2011 13:46'!att3Block: aValue	att3Block := aValue! !!StompMockFixedNewFailedClass methodsFor: 'initializing-stomp' stamp: 'mu 4/26/2011 14:17'!stompInitialize	att3Block := [:a :b | a < b].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StompMockFixedNewFailedClass class	instanceVariableNames: ''!!StompMockFixedNewFailedClass class methodsFor: 'instance creation' stamp: 'mu 4/26/2011 13:46'!new	^Error new signal: '#new should not be used!!'! !!StompMockFixedNewFailedClass class methodsFor: 'for tests' stamp: 'mu 4/26/2011 13:46'!prototype1	"self prototype1"	| inst |	inst := self basicNew.	inst att1: 1.	inst att2: 'TWO'.	inst att3Block: [:this | 'is block'].	^inst! !StompMockFixedNewFailedClass subclass: #StompMockFixedAlternativeClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StompMockFixedAlternativeClass class	instanceVariableNames: ''!!StompMockFixedAlternativeClass class methodsFor: 'instance creation' stamp: 'mu 4/26/2011 13:47'!new	"new is OK for me"	^self basicNew! !Array variableSubclass: #StompMockMementoArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockMementoArray methodsFor: 'stomp-objectstream-reading' stamp: 'mu 3/6/2011 14:12'!stompReadValue	| inst |	inst := StompMockCustomWriteObject new.	inst name: (self at: 1).	inst email: (self at: 2).	^inst! !Array variableSubclass: #StompMockMixedClass	instanceVariableNames: 'instVar1 instVar2'	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockMixedClass methodsFor: 'comparing' stamp: 'mu 2/2/2011 23:57'!equals: other	self class = other class ifFalse: [^false].	instVar1 = other instVar1 ifFalse: [^false].	instVar2 = other instVar2 ifFalse: [^false].	^super = other! !!StompMockMixedClass methodsFor: 'accessing' stamp: 'mu 1/3/2011 00:31'!instVar1	"Answer the value of instVar1"	^ instVar1! !!StompMockMixedClass methodsFor: 'accessing' stamp: 'mu 1/3/2011 00:31'!instVar1: anObject	"Set the value of instVar1"	instVar1 := anObject! !!StompMockMixedClass methodsFor: 'accessing' stamp: 'mu 1/3/2011 00:31'!instVar2	"Answer the value of instVar2"	^ instVar2! !!StompMockMixedClass methodsFor: 'accessing' stamp: 'mu 1/3/2011 00:31'!instVar2: anObject	"Set the value of instVar2"	instVar2 := anObject! !!StompMockMixedClass methodsFor: 'testing' stamp: 'mu 1/3/2011 00:51'!stompShouldWriteInstanceVariables	^true	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StompMockMixedClass class	instanceVariableNames: ''!!StompMockMixedClass class methodsFor: 'instance creation' stamp: 'mu 4/25/2011 23:42'!new	^super new! !StompMockFixedClass subclass: #StompMockObjectInitializingOnRead	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockObjectInitializingOnRead methodsFor: 'initialize-release' stamp: 'mu 2/22/2011 00:18'!stompInitialize	instVar1 := 'stomp initialized 1'.	instVar2 := 'stomp initialized 2'! !StompMockFixedClass subclass: #StompMockObjectPreparingOnWrite	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockObjectPreparingOnWrite methodsFor: 'stomp-objectstream-writing' stamp: 'mu 3/3/2011 00:14'!stompPrepareWrite 	self instVar1: self instVar1 printString.	self instVar2: self instVar2 * 2.! !StompMockFixedClass subclass: #StompMockObjectWithCache	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockObjectWithCache methodsFor: 'stomp-objectstream-writing' stamp: 'mu 3/3/2011 00:20'!stompTransientInstVarNames	^#(instVar1 instVar2 instVar3)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StompMockObjectWithCache class	instanceVariableNames: 'att1 att2 cache1'!!StompMockObjectWithCache class methodsFor: 'accessing' stamp: 'mu 3/3/2011 23:35'!att1	"Answer the value of att1"	^ att1! !!StompMockObjectWithCache class methodsFor: 'accessing' stamp: 'mu 3/3/2011 23:35'!att1: anObject	"Set the value of att1"	att1 := anObject! !!StompMockObjectWithCache class methodsFor: 'accessing' stamp: 'mu 3/3/2011 23:35'!att2	"Answer the value of att2"	^ att2! !!StompMockObjectWithCache class methodsFor: 'accessing' stamp: 'mu 3/3/2011 23:35'!att2: anObject	"Set the value of att2"	att2 := anObject! !!StompMockObjectWithCache class methodsFor: 'accessing' stamp: 'mu 3/3/2011 23:35'!cache1	"Answer the value of cache1"	^ cache1! !!StompMockObjectWithCache class methodsFor: 'accessing' stamp: 'mu 3/3/2011 23:35'!cache1: anObject	"Set the value of cache1"	cache1 := anObject! !!StompMockObjectWithCache class methodsFor: 'stomp-objectstream-writing' stamp: 'mu 3/4/2011 00:27'!stompTransientInstVarNames	^super stompTransientInstVarNames, #(cache1)! !Object subclass: #StompMockPerson	instanceVariableNames: 'name requests partners'	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockPerson methodsFor: 'accessing' stamp: 'mu 4/26/2011 23:28'!name	^name! !!StompMockPerson methodsFor: 'accessing' stamp: 'mu 4/26/2011 23:28'!name: aString	name := aString! !!StompMockPerson methodsFor: 'accessing' stamp: 'mu 4/26/2011 23:52'!partners	partners isNil ifTrue: [partners := Array new].	^ partners! !!StompMockPerson methodsFor: 'accessing' stamp: 'mu 4/26/2011 23:28'!partners: anObject	partners := anObject! !!StompMockPerson methodsFor: 'accessing' stamp: 'mu 4/26/2011 23:52'!requests	requests isNil ifTrue: [requests := Array new].	^ requests! !!StompMockPerson methodsFor: 'accessing' stamp: 'mu 4/26/2011 23:28'!requests: anObject	requests := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StompMockPerson class	instanceVariableNames: ''!!StompMockPerson class methodsFor: 'examples' stamp: 'mu 5/28/2011 21:28'!example1	"self example1"	| req1 req2 person1 person2 |	req1 := StompMockRequest new.	req1 id: 1.	req2 := StompMockRequest new.		req2 id: 2.	person1 := StompMockPerson new name: 'A'.	person1 requests: (Array with: req1 with: req2).	person2 := StompMockPerson new name: 'B'.	person2 partners: (Array with: person1).	req1 owner: person1.	req2 owner: person2.	^person1	! !StompShapeChanger subclass: #StompMockPersonShapeChanger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockPersonShapeChanger methodsFor: 'actions' stamp: 'mu 6/1/2011 14:48'!loadInstVarAt: varIndex named: varName put: varValue 	varName = 'fullName' ifTrue: [^ self targetInstance name: varValue ].			^ super loadInstVarAt: varIndex named: varName put: varValue ! !Object subclass: #StompMockRequest	instanceVariableNames: 'id owner'	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockRequest methodsFor: 'accessing' stamp: 'mu 4/26/2011 23:29'!id	^ id! !!StompMockRequest methodsFor: 'accessing' stamp: 'mu 4/26/2011 23:29'!id: anObject	id := anObject! !!StompMockRequest methodsFor: 'accessing' stamp: 'mu 4/26/2011 23:29'!owner	^ owner! !!StompMockRequest methodsFor: 'accessing' stamp: 'mu 4/26/2011 23:29'!owner: anObject	owner := anObject! !Object subclass: #StompMockShapeChangedObject	instanceVariableNames: 'renamedAtt1 addedAtt1 originalAtt1'	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockShapeChangedObject methodsFor: 'accessing' stamp: 'mu 4/26/2011 16:13'!addedAtt1	"Answer the value of addedAtt1"	^ addedAtt1! !!StompMockShapeChangedObject methodsFor: 'accessing' stamp: 'mu 4/26/2011 16:13'!addedAtt1: anObject	"Set the value of addedAtt1"	addedAtt1 := anObject! !!StompMockShapeChangedObject methodsFor: 'accessing' stamp: 'mu 4/26/2011 16:13'!originalAtt1	"Answer the value of originalAtt1"	^ originalAtt1! !!StompMockShapeChangedObject methodsFor: 'accessing' stamp: 'mu 4/26/2011 16:13'!originalAtt1: anObject	"Set the value of originalAtt1"	originalAtt1 := anObject! !!StompMockShapeChangedObject methodsFor: 'accessing' stamp: 'mu 4/26/2011 16:13'!renamedAtt1	"Answer the value of renamedAtt1"	^ renamedAtt1! !!StompMockShapeChangedObject methodsFor: 'accessing' stamp: 'mu 4/26/2011 16:13'!renamedAtt1: anObject	"Set the value of renamedAtt1"	renamedAtt1 := anObject! !!StompMockShapeChangedObject methodsFor: 'reading-stomp' stamp: 'mu 4/26/2011 16:20'!stompInitialize	addedAtt1 := 2! !!StompMockShapeChangedObject methodsFor: 'reading-stomp' stamp: 'mu 6/1/2011 14:20'!stompInstVarAt: instVarIndex named: varName put: value 	varName = 'oldNamedVar1' ifTrue: [^self renamedAtt1: value].	super stompInstVarAt: instVarIndex named: varName put: value ! !StompShapeChanger subclass: #StompMockShapeChanger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockShapeChanger methodsFor: 'actions' stamp: 'mu 4/22/2011 23:33'!loadAdditions	self targetInstance instVar5: 'FIVE'.! !!StompMockShapeChanger methodsFor: 'actions' stamp: 'mu 6/1/2011 14:31'!loadInstVarAt: varIndex named: varName put: varValue 	"renamed"	varName = 'instVar2OLD' ifTrue: [^ self targetInstance instVar2: varValue ].		"removed"	"varName = 'instVar6' ifTrue: [^ self]."		^ super loadInstVarAt: varIndex named: varName put: varValue ! !StompShapeChanger subclass: #StompMockShapeChangerForRenamedComplexRead	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockShapeChangerForRenamedComplexRead methodsFor: 'actions' stamp: 'mu 4/26/2011 22:55'!loadAdditions	self targetInstance addedAtt1: 22222! !!StompMockShapeChangerForRenamedComplexRead methodsFor: 'actions' stamp: 'mu 6/1/2011 14:29'!loadInstVarAt: varIndex named: varName put: varValue 	"renamed"	varName = 'oldNamedVar1' ifTrue: [^ self targetInstance renamedAtt1: varValue ].			^ super loadInstVarAt: varIndex named: varName put: varValue ! !Array variableSubclass: #StompMockVariableClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!Array variableSubclass: #StompMockVariableNewFailedClass	instanceVariableNames: 'att1 att2 att3Block'	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompMockVariableNewFailedClass methodsFor: 'accessing' stamp: 'mu 4/26/2011 14:51'!att1	^att1! !!StompMockVariableNewFailedClass methodsFor: 'accessing' stamp: 'mu 4/26/2011 14:51'!att1: aValue	att1 := aValue! !!StompMockVariableNewFailedClass methodsFor: 'accessing' stamp: 'mu 4/26/2011 14:51'!att2	^att2! !!StompMockVariableNewFailedClass methodsFor: 'accessing' stamp: 'mu 4/26/2011 14:51'!att2: aValue	att2 := aValue! !!StompMockVariableNewFailedClass methodsFor: 'accessing' stamp: 'mu 4/26/2011 14:51'!att3Block	^att3Block! !!StompMockVariableNewFailedClass methodsFor: 'accessing' stamp: 'mu 4/26/2011 14:51'!att3Block: aValue	att3Block := aValue! !!StompMockVariableNewFailedClass methodsFor: 'initializing-stomp' stamp: 'mu 4/26/2011 15:05'!stompInitialize	att3Block := [:a :b | a < b].! !!StompMockVariableNewFailedClass methodsFor: 'testing-stomp' stamp: 'mu 4/26/2011 15:09'!stompShouldWriteInstanceVariables 	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StompMockVariableNewFailedClass class	instanceVariableNames: ''!!StompMockVariableNewFailedClass class methodsFor: 'instance creation' stamp: 'mu 4/26/2011 14:51'!new: size	Error new signal: '#new: should not be called'! !!StompMockVariableNewFailedClass class methodsFor: 'for tests' stamp: 'mu 4/26/2011 14:51'!prototype1	"self prototype1"	| inst |	inst := self basicNew: 3.	1 to: 3 do: [:idx | inst at: idx put: idx printString].	inst att1: 1.	inst att2: 'TWO'.	inst att3Block: [:this | 'is block'].	^inst! !StompMockVariableNewFailedClass variableSubclass: #StompMockVariableAlternativeClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StompMockVariableAlternativeClass class	instanceVariableNames: ''!!StompMockVariableAlternativeClass class methodsFor: 'instance creation' stamp: 'mu 4/26/2011 14:54'!new: size	"new: is OK for me"	^self basicNew: size! !TestCase subclass: #StompNewFailedTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompNewFailedTestCase methodsFor: 'tests' stamp: 'mu 4/26/2011 14:46'!testWriteReadNewFailedClass	"self debug: #testWriteReadNewFailedClass"	| original stomp read |	original := StompMockFixedNewFailedClass prototype1.	self should: [original att1 = 1].	self should: [original att2 =  'TWO']. 	self should: [original toStomp] raise: StompInvalidSerialization.	stomp := original toStomp.		self should: [Object fromStomp: stomp] raise: StompNewFailed.	read := Object fromStomp: stomp.	self should: [read att1 = 1].	self should: [read att2 =  'TWO'].	self should: [read att3Block notNil].				! !!StompNewFailedTestCase methodsFor: 'tests' stamp: 'mu 4/26/2011 14:48'!testWriteReadNewFailedClassReceiverAlternative	"self debug: #testWriteReadNewFailedClassReceiverAlternative"	| original stomp read |	original := StompMockFixedNewFailedClass prototype1.	self should: [original att1 = 1].	self should: [original att2 =  'TWO']. 	self should: [original toStomp] raise: StompInvalidSerialization.	stomp := original toStomp.		self should: [Object fromStomp: stomp] raise: StompNewFailed.	read := [Object fromStomp: stomp] on: StompNewFailed do: [:ex | ex resume: StompMockFixedAlternativeClass].	self should: [read class = StompMockFixedAlternativeClass].	self should: [read att1 = 1].	self should: [read att2 =  'TWO'].	self should: [read att3Block notNil].				! !!StompNewFailedTestCase methodsFor: 'tests' stamp: 'mu 4/26/2011 15:10'!testWriteReadNewVariableFailedClass	"self debug: #testWriteReadNewVariableFailedClass"	| original stomp read |	original := StompMockVariableNewFailedClass prototype1.	self should: [original att1 = 1].	self should: [original att2 =  'TWO']. 	self should: [original toStomp] raise: StompInvalidSerialization.	stomp := original toStomp.		self should: [Object fromStomp: stomp] raise: StompNewFailed.	read := Object fromStomp: stomp.	self should: [read att1 = 1].	self should: [read att2 =  'TWO'].	self should: [read att3Block notNil].				! !!StompNewFailedTestCase methodsFor: 'tests' stamp: 'mu 4/26/2011 15:10'!testWriteReadNewVariableFailedClassReciverAlternative	"self debug: #testWriteReadNewVariableFailedClassReciverAlternative"	| original stomp read |	original := StompMockVariableNewFailedClass prototype1.	self should: [original att1 = 1].	self should: [original att2 =  'TWO']. 	self should: [original toStomp] raise: StompInvalidSerialization.	stomp := original toStomp.		self should: [Object fromStomp: stomp] raise: StompNewFailed.	read := [Object fromStomp: stomp] on: StompNewFailed do: [:ex | ex resume: StompMockVariableAlternativeClass].	self should: [read class = StompMockVariableAlternativeClass].	self should: [read att1 = 1].	self should: [read att2 =  'TWO'].	self should: [read att3Block notNil].				! !Object subclass: #StompPortableFixtures	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StompPortableFixtures class	instanceVariableNames: ''!!StompPortableFixtures class methodsFor: 'fixtures' stamp: 'mu 4/8/2011 22:28'!blueColor	self subclassResponsibility ! !!StompPortableFixtures class methodsFor: 'fixtures' stamp: 'mu 6/3/2011 11:49'!double1234567890dot123456789	"^ 1234567890.123456789d"	self subclassResponsibility! !!StompPortableFixtures class methodsFor: 'fixtures' stamp: 'mu 6/3/2011 11:31'!double3dot3	"^ 3.3d"	self subclassResponsibility! !!StompPortableFixtures class methodsFor: 'fixtures' stamp: 'mu 6/3/2011 11:26'!float1dot2bytes	^ #[202 63 153 153 154]! !!StompPortableFixtures class methodsFor: 'fixtures' stamp: 'mu 5/10/2011 13:51'!timestamp1	self subclassResponsibility! !!StompPortableFixtures class methodsFor: 'fixtures' stamp: 'mu 4/8/2011 22:51'!yellowColor	self subclassResponsibility ! !TestCase subclass: #StompTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompTestCase methodsFor: 'fixtures' stamp: 'mu 7/15/2011 23:52'!bagAnswerBytes	^#[147 161 2 255 148 30 30 20 10]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 5/25/2011 00:25'!basicArrayAnswerBytes	^#[148 1 2 3 147 146 161 4 165 72 101 108 108 111 2 3]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 5/9/2011 15:49'!basicBitsClassAnswerBytes	^#[147 161 2 129 17 218 0 18 83 116 111 109 112 77 111 99 107 66 121 116 101 65 114 114 97 121 163 0 127 255]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 5/25/2011 00:25'!basicFixedClassAnswerBytes	^#[147 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 129 149 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 168 105 110 115 116 86 97 114 51 168 105 110 115 116 86 97 114 52 168 105 110 115 116 86 97 114 53 149 1 146 161 5 163 116 119 111 203 64 10 102 102 102 102 102 102 194 146 161 4 164 70 73 86 69]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 5/25/2011 00:27'!basicMixedClassAnswerBytes	^#[149 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 77 105 120 101 100 67 108 97 115 115 3 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 146 195 194 146 192 144 147 1 146 161 4 163 116 119 111 203 64 10 102 102 102 102 102 102]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 5/25/2011 00:28'!basicVariableClassAnswerBytes	^#[147 161 2 129 17 218 0 22 83 116 111 109 112 77 111 99 107 86 97 114 105 97 98 108 101 67 108 97 115 115 147 1 146 161 4 163 116 119 111 203 64 10 102 102 102 102 102 102]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 5/25/2011 00:28'!circularRefrencesAnswerBytes	^#[148 147 161 2 129 17 218 0 22 83 116 111 109 112 77 111 99 107 86 97 114 105 97 98 108 101 67 108 97 115 115 147 1 146 161 4 163 116 119 111 146 161 3 1 149 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 77 105 120 101 100 67 108 97 115 115 3 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 146 161 3 1 146 161 3 2 147 1 146 161 4 163 116 119 111 203 64 10 102 102 102 102 102 102 146 161 3 1 146 161 3 2]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 5/25/2011 00:52'!classAnswerBytes	^#[147 161 2 129 17 218 0 25 83 116 111 109 112 77 111 99 107 79 98 106 101 99 116 87 105 116 104 67 97 99 104 101 36 129 146 164 97 116 116 49 164 97 116 116 50 146 11 22]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 6/6/2011 11:07'!classNameAndIdsAnswerBytes	^#[148 147 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 129 149 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 168 105 110 115 116 86 97 114 51 168 105 110 115 116 86 97 114 52 168 105 110 115 116 86 97 114 53 149 1 146 161 5 163 111 110 101 192 192 192 147 161 2 0 150 0 2 146 161 5 163 116 119 111 192 192 192 149 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 77 105 120 101 100 67 108 97 115 115 0 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 3 146 161 5 165 116 104 114 101 101 144 149 161 2 1 0 147 1 4 146 161 5 164 102 111 117 114 144]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 6/6/2011 11:12'!classNameAndIdsSuppressNilWritesAnswerBytes	^#[148 147 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 1 146 161 5 163 111 110 101 147 161 2 0 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 2 146 161 5 163 116 119 111 149 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 77 105 120 101 100 67 108 97 115 115 0 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 3 146 161 5 165 116 104 114 101 101 144 149 161 2 1 0 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 4 146 161 5 164 102 111 117 114 144]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 7/15/2011 23:54'!colorAnswerBytes1	^#[147 161 2 252 147 203 0 0 0 0 0 0 0 0 203 0 0 0 0 0 0 0 0 203 63 240 0 0 0 0 0 0]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 7/15/2011 23:57'!colorAnswerBytes2	^#[147 161 2 252 147 203 63 240 0 0 0 0 0 0 203 63 240 0 0 0 0 0 0 203 0 0 0 0 0 0 0 0]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 5/25/2011 00:55'!compositeDictionaryAnswerBytes	^#[132 146 161 5 167 112 97 114 101 110 116 52 129 146 161 5 166 99 104 105 108 100 49 146 161 4 165 97 98 99 100 101 146 161 5 167 112 97 114 101 110 116 50 100 146 161 5 167 112 97 114 101 110 116 51 147 10 20 30 146 161 5 167 112 97 114 101 110 116 49 146 161 4 174 115 97 109 112 108 101 32 115 116 114 105 110 103 46]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 7/15/2011 23:54'!dateAnswerBytes	^#[147 161 2 250 206 190 169 158 128]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 6/3/2011 12:35'!dictionaryAnswerBytes	^#[131 146 161 5 164 107 101 121 51 146 161 4 166 118 97 108 117 101 51 146 161 5 164 107 101 121 49 146 161 4 166 118 97 108 117 101 49 146 161 5 164 107 101 121 50 146 161 4 166 118 97 108 117 101 50]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 7/15/2011 23:57'!durationAnswerBytes	^#[147 161 2 239 207 0 0 0 28 163 95 14 0]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 5/25/2011 01:14'!fixedClassWithNilValuesAnswerBytes	^#[147 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 129 147 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 51 168 105 110 115 116 86 97 114 53 147 1 203 64 10 102 102 102 102 102 102 146 161 4 164 70 73 86 69]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 6/3/2011 11:27'!floatingPointAnswerBytes1	^ StompPortableUtil default testFixturesClass float1dot2bytes! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 6/3/2011 11:27'!floatingPointAnswerBytes2	"double"	^#[203 65 210 101 128 180 135 230 183]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 7/15/2011 23:58'!fractionAnswerBytes	^#[147 161 2 249 146 3 4]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 7/15/2011 23:52'!intervalAnswerBytes	^#[147 161 2 246 147 1 10 3]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 6/6/2011 11:04'!mixedClassNoVariableDataAnswerBytes	^#[149 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 77 105 120 101 100 67 108 97 115 115 0 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 146 195 194 146 192 144 144]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 7/15/2011 23:58'!ordredCollectionAnswerBytes	^#[147 161 2 245 147 10 20 30]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 7/15/2011 23:55'!rectangleAnswerBytes	^#[147 161 2 243 148 1 1 3 4]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 5/10/2011 12:04'!recursiveArrayAnswerBytes	^#[147 10 20 146 161 3 0]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 7/15/2011 23:56'!runArrayAnswerBytes	^#[147 161 2 236 146 147 1 2 1 147 1 2 3]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 7/15/2011 23:53'!setAnswerBytes	^ #[147 161 2 242 147 10 20 30]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 5/25/2011 00:59'!sharedReferenceAnswerBytes	^#[148 147 161 2 129 17 218 0 22 83 116 111 109 112 77 111 99 107 86 97 114 105 97 98 108 101 67 108 97 115 115 147 1 146 161 4 163 116 119 111 203 64 10 102 102 102 102 102 102 149 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 77 105 120 101 100 67 108 97 115 115 3 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 146 195 194 146 192 144 147 1 146 161 4 163 116 119 111 203 64 10 102 102 102 102 102 102 146 161 3 1 146 161 3 2]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 5/25/2011 01:00'!stringAnswerBytes	^#[146 161 4 218 0 21 72 105 44 32 73 39 109 32 83 116 114 105 110 103 45 111 98 106 101 99 116]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 5/25/2011 01:01'!symbolAnswerBytes	^#[146 161 5 167 97 98 99 100 101 102 103]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 7/15/2011 23:55'!timeAnswerBytes	^#[147 161 2 238 206 0 1 72 104]! !!StompTestCase methodsFor: 'fixtures' stamp: 'mu 7/15/2011 23:55'!timestampAnswerBytes	^#[147 161 2 237 207 46 57 36 122 10 159 20 0]! !StompTestCase subclass: #StompReadWriteTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompReadWriteTestCase methodsFor: 'tests' stamp: 'mu 7/10/2011 23:11'!testReadWriteText	"self debug: #testReadWriteText"	| bytes orig text |	(StompPortableUtil default classNamed: #Text) ifNil: [^self].	orig := 'aaa' asText allBold.	bytes := orig toStomp.	text := Object fromStomp: bytes.		self should: [orig = text]! !StompTestCase subclass: #StompReaderTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompReaderTestCase methodsFor: 'private' stamp: 'mu 7/10/2011 22:36'!collectionEquals: aCollection with: otherCollection	^MpPortableUtil default collectionEquals: aCollection with: otherCollection! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 23:43'!testReadBag	"self debug: #testReadBag"		| bytes inst |	bytes := self bagAnswerBytes.	inst := Object fromStomp: bytes.		self should: [inst class = Bag].	self		should: [inst size = 4].	self		should: [inst includes: 10].	self		should: [inst includes: 20].	self		should: [inst includes: 30].	self		should: [(inst occurrencesOf: 30) = 2]! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:03'!testReadBasicArray	"self debug: #testReadBasicArray"	| bytes obj |	bytes := self basicArrayAnswerBytes.	obj := (StompReader onBytes: bytes) next.		self should: [obj class = Array].	self should: [obj = #(1 2 3 #('Hello' 2 3))]! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:03'!testReadBasicBitsClass	"self debug: #testReadBasicBitsClass"	| bytes obj expected |	bytes := self basicBitsClassAnswerBytes.	obj := (StompReader onBytes: bytes) next.		expected := StompMockByteArray new: 3.	expected at: 1 put: 0.	expected at: 2 put: 127.	expected at: 3 put: 255.	self should: [obj = expected].			! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 6/2/2011 23:48'!testReadBasicFixedClass	"self debug: #testReadBasicFixedClass"	| bytes obj expected |	bytes := self basicFixedClassAnswerBytes.	obj := (StompReader onBytes: bytes) next.		expected := StompMockFixedClass new.	expected instVar1: 1.	expected instVar2: #two.	expected instVar3: (StompPortableUtil default testFixturesClass double3dot3).	expected instVar4: false.	expected instVar5: 'FIVE'.		self should: [obj equals: expected].				! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 6/2/2011 23:48'!testReadBasicMixedClass	"self debug: #testReadBasicMixedClass"	| bytes obj expected |	bytes := self basicMixedClassAnswerBytes.	obj := (StompReader onBytes: bytes) next.		expected := StompMockMixedClass new: 3.	expected at: 1 put: 1.	expected at: 2 put: 'two'.	expected at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).	expected instVar1: #(true false).	expected instVar2: #(nil #()).		self should: [obj equals: expected]				! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 6/2/2011 23:49'!testReadBasicVariableClass	"self debug: #testReadBasicVariableClass"	| bytes obj expected |	bytes := self basicVariableClassAnswerBytes.	obj := (StompReader onBytes: bytes) next.		expected := StompMockVariableClass new: 3.	expected at: 1 put: 1.	expected at: 2 put: 'two'.	expected at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).		self should: [obj = expected]				! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:08'!testReadBoolean	"self debug: #testReadBoolean"		self should: [(Object fromStomp: (#[195])) = true].	self should: [(Object fromStomp: (#[194])) = false].! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:08'!testReadByteArray	"self debug: #testReadByteArray"		| byteArray |	byteArray := (ByteArray with: 10 with: 20 with: 30).		self should: [(Object fromStomp: (#[163 10 20 30])) = byteArray].	! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 7/16/2011 00:02'!testReadCharacter	"self debug: #testReadCharacter"		| char1 char2 |	char1 := $A.		self should: [(Object fromStomp:(#[147 161 2 253 65])) = char1].	char2 := (StompPortableUtil default characterFromUnicode: 12354). "Japanese Hiragana 'A' "		self should: [(Object fromStomp:(#[147 161 2 253 205 48 66])) = char2].		! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 6/3/2011 00:13'!testReadCircularRefrences1	"self debug: #testReadCircularRefrences1"	| bytes reader obj inst1 inst2 expected |	bytes := self circularRefrencesAnswerBytes.	reader := StompReader onBytes: bytes.	obj := reader next.		inst1 := StompMockVariableClass new: 3.	inst1 at: 1 put: 1.	inst1 at: 2 put: 'two'.	inst1 at: 3 put: inst1.		inst2 := StompMockMixedClass new: 3.	inst2 at: 1 put: 1.	inst2 at: 2 put: 'two'.	inst2 at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).	inst2 instVar1: inst1.	inst2 instVar2: inst2.		expected := Array with: inst1 with: inst2 with: inst1 with: inst2.		self should: [obj class = expected class].	self should: [obj size = expected size]. 		self should: [(obj at: 1) class = StompMockVariableClass].	self should: [(obj at: 1) class = (expected at: 1) class].	self should: [((obj at: 1) at: 1) = 1].	self should: [((obj at: 1) at: 1) = ((expected at: 1) at: 1)].	self should: [((obj at: 1) at: 2) = 'two'].	self should: [((obj at: 1) at: 2) = ((expected at: 1) at: 2)].	self should: [((obj at: 1) at: 3) class = StompMockVariableClass].	self should: [((obj at: 1) at: 3) class = ((expected at: 1) at: 3) class].	self should: [(obj at: 1) identityHash = ((obj at: 1) at: 3) identityHash].		self should: [(obj at: 2) class = StompMockMixedClass].	self should: [(obj at: 2) class = (expected at: 2) class].	self should: [((obj at: 2) at: 1) = 1].	self should: [((obj at: 2) at: 1) = ((expected at: 2) at: 1)].	self should: [((obj at: 2) at: 2) = 'two'].	self should: [((obj at: 2) at: 2) = ((expected at: 2) at: 2)].	self should: [((obj at: 2) at: 3) = (StompPortableUtil default testFixturesClass double3dot3)].	self should: [((obj at: 2) at: 3) = ((expected at: 2) at: 3)].	self should: [((obj at: 2) instVar1) class = StompMockVariableClass].	self should: [((obj at: 2) instVar1) class = ((expected at: 2) instVar1) class].	self should: [(obj at: 2) instVar1 identityHash = (obj at: 1) identityHash].	self should: [((obj at: 2) instVar2) class = StompMockMixedClass].	self should: [((obj at: 2) instVar2) class = ((expected at: 2) instVar2) class].	self should: [(obj at: 2) instVar2 identityHash = (obj at: 2) identityHash].		self should: [(obj at: 3) class = StompMockVariableClass].	self should: [(obj at: 3) class = (expected at: 3) class].	self should: [((obj at: 3) at: 1) = 1].	self should: [((obj at: 3) at: 1) = ((expected at: 3) at: 1)].	self should: [((obj at: 3) at: 2) = 'two'].	self should: [((obj at: 3) at: 2) = ((expected at: 3) at: 2)].	self should: [((obj at: 3) at: 3) class = StompMockVariableClass].	self should: [((obj at: 3) at: 3) class = ((expected at: 3) at: 3) class].	self should: [(obj at: 3) identityHash = ((obj at: 3) at: 3) identityHash].		self should: [(obj at: 4) class = StompMockMixedClass].	self should: [(obj at: 4) class = (expected at: 4) class].	self should: [((obj at: 4) at: 1) = 1].	self should: [((obj at: 4) at: 1) = ((expected at: 4) at: 1)].	self should: [((obj at: 4) at: 2) = 'two'].	self should: [((obj at: 4) at: 2) = ((expected at: 4) at: 2)].	self should: [((obj at: 4) at: 3) = (StompPortableUtil default testFixturesClass double3dot3)].	self should: [((obj at: 4) at: 3) = ((expected at: 4) at: 3)].	self should: [((obj at: 4) instVar1) class = StompMockVariableClass].	self should: [((obj at: 4) instVar1) class = ((expected at: 4) instVar1) class].	self should: [(obj at: 4) instVar1 identityHash = (obj at: 1) identityHash].	self should: [((obj at: 4) instVar2) class = StompMockMixedClass].	self should: [((obj at: 4) instVar2) class = ((expected at: 4) instVar2) class].	self should: [(obj at: 4) instVar2 identityHash = (obj at: 2) identityHash].				! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 23:59'!testReadClass	"self debug: #testReadClass"	| cls |	cls := StompMockObjectWithCache.	cls att1: 11.	cls att2: 22.	self should: [(Object fromStomp: (self classAnswerBytes)) = cls]		! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:09'!testReadClassNameAndIds	"self debug: #testReadClassNameAndIds"		| bytes obj data1 data2 data3 data4 expected |	bytes := self classNameAndIdsAnswerBytes.	obj := (StompReader onBytes: bytes) next.		data1 := StompMockFixedClass new.	data1 instVar1: 1.	data1 instVar2: #one.		data2 := StompMockFixedClass new.	data2 instVar1: 2.	data2 instVar2: #two.		data3 := StompMockMixedClass new.	data3 instVar1: 3.	data3 instVar2: #three.		data4 := StompMockMixedClass new.	data4 instVar1: 4.	data4 instVar2: #four.		expected := Array with: data1 with: data2 with: data3 with: data4.		self should: [(obj at: 1) equals: (expected at: 1)].	self should: [(obj at: 2) equals: (expected at: 2)].	self should: [(obj at: 3) equals: (expected at: 3)].	self should: [(obj at: 4) equals: (expected at: 4)]				! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/12/2011 22:11'!testReadClassNameAndIdsSuppressNilWrites	"self debug: #testReadClassNameAndIdsSuppressNilWrites"		| bytes obj data1 data2 data3 data4 expected |	bytes := self classNameAndIdsSuppressNilWritesAnswerBytes.	obj := (StompReader onBytes: bytes) next.		data1 := StompMockFixedClass new.	data1 instVar1: 1.	data1 instVar2: #one.		data2 := StompMockFixedClass new.	data2 instVar1: 2.	data2 instVar2: #two.		data3 := StompMockMixedClass new.	data3 instVar1: 3.	data3 instVar2: #three.		data4 := StompMockMixedClass new.	data4 instVar1: 4.	data4 instVar2: #four.		expected := Array with: data1 with: data2 with: data3 with: data4.		self should: [(obj at: 1) equals: (expected at: 1)].	self should: [(obj at: 2) equals: (expected at: 2)].	self should: [(obj at: 3) equals: (expected at: 3)].	self should: [(obj at: 4) equals: (expected at: 4)]				! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:06'!testReadColor	"self debug: #testReadColor"	| color1 color2 |	color1 := StompPortableUtil default testFixturesClass blueColor.	self should: [(Object fromStomp:(self colorAnswerBytes1)) = color1].		color2 := StompPortableUtil default testFixturesClass yellowColor.	self should: [(Object fromStomp:(self colorAnswerBytes2)) = color2]		! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 7/10/2011 23:19'!testReadCompositeDictionary	"self debug: #testReadCompositeDictionary"	| childDic dic readDic |	childDic := Dictionary new.	childDic at: #child1 put: 'abcde'.	dic := Dictionary new.	dic at: #parent1 put: 'sample string.'.	dic at: #parent2 put: 100.	dic at: #parent3 put: #(10 20 30 ).	dic at: #parent4 put: childDic.		readDic := Object fromStomp: (self compositeDictionaryAnswerBytes).		self should: [readDic size = dic size].	self should: [(readDic at: #parent1) = (dic at: #parent1)].	self should: [(readDic at: #parent2) = (dic at: #parent2)].	self should: [self collectionEquals: (readDic at: #parent3) with: (dic at: #parent3)].	self should: [self collectionEquals: (readDic at: #parent4) associations with: (dic at: #parent4) associations].! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:10'!testReadDate	"self debug: #testReadDate"		| bytes inst |	bytes := self dateAnswerBytes.	inst := Object fromStomp: bytes.		self should: [inst class = Date].	self should: [inst = (Date fromDays: 37023)].	! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 7/10/2011 22:37'!testReadDictionary	"self debug: #testReadDictionary"	| dic |	dic := Dictionary new.	dic at: #key1 put: 'value1'.	dic at: #key2 put: 'value2'.	dic at: #key3 put: 'value3'.		self should: [self collectionEquals: (Object fromStomp: (self dictionaryAnswerBytes)) with: dic]! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 6/1/2011 23:31'!testReadDuration	"self debug: #testReadDuration"		| duration inst |	duration := self durationAnswerBytes.	inst := Object fromStomp: duration.		self should: [inst class = Duration].	self should: [inst = 123 seconds].	! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 6/2/2011 23:50'!testReadFixedClassWithNilValues	"self debug: #testReadFixedClassWithNilValues"	| data |	data := StompMockFixedClass new.	data instVar1: 1.	data instVar2: nil.	data instVar3: (StompPortableUtil default testFixturesClass double3dot3).	data instVar4: nil.	data instVar5: 'FIVE'.	self		should: [data				equals: (Object						fromStomp: self fixedClassWithNilValuesAnswerBytes						setting: [:ctx | ctx settings suppressNilWrite: true])]! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:11'!testReadFraction	"self debug: #testReadFraction"	| fra |	fra := 3 / 4.		self should: [(Object fromStomp: (self fractionAnswerBytes)) = fra]! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:11'!testReadInterval	"self debug: #testReadInterval"	| interval |	interval := 1 to: 10 by: 3.		self should: [(Object fromStomp: (self intervalAnswerBytes)) = interval]	! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:11'!testReadMixedClassNoVariableData	"self debug: #testReadMixedClassNoVariableData"	| data |	data := StompMockMixedClass new.	data instVar1: #(true false).	data instVar2: #(nil #()).	self should: [data equals: (Object fromStomp:(self mixedClassNoVariableDataAnswerBytes))]	! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 6/3/2011 11:52'!testReadNumber	"self debug: #testReadNumber"	self should: [(Object fromStomp:(#[1])) = 1].	self should: [(Object fromStomp:(self floatingPointAnswerBytes1)) = 1.2].	self should: [(Object fromStomp:(self floatingPointAnswerBytes2))  = StompPortableUtil default testFixturesClass double1234567890dot123456789]! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:12'!testReadOrdredCollection	"self debug: #testReadOrdredCollection"	| ord |	ord := OrderedCollection new.	ord add: 10.	ord add: 20.	ord add: 30.		self should: [(Object fromStomp:(self ordredCollectionAnswerBytes)) = ord]	! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:13'!testReadRectangle	"self debug: #testReadRectangle"	| rect |	rect := (1@1 corner: 3@4).		self should: [(Object fromStomp:(self rectangleAnswerBytes)) = rect]		! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/10/2011 12:05'!testReadRecursiveArray	"self debug: #testReadRecursiveArray"	| arr readArray |	arr := Array new: 3.	arr at: 1 put: 10.	arr at: 2 put: 20.	arr at: 3 put: arr.		readArray := (Object fromStomp:(self recursiveArrayAnswerBytes)).		self should: [readArray size = arr size].	self should: [(readArray at: 1) = (arr at: 1)].	self should: [(readArray at: 2) = (arr at: 2)].	self should: [(readArray at: 3) identityHash= readArray identityHash].		! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:13'!testReadRunArray	"self debug: #testReadRunArray"	| arr |	arr := RunArray runs: #(1 2 1) values: #(1 2 3).	self should: [(Object fromStomp:(self runArrayAnswerBytes)) = arr]	! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 23:44'!testReadSet	"self debug: #testReadSet"	| set |	set := Set new.	set add: 10.	set add: 20.	set add: 30.	set add: 30.		self should: [(Object fromStomp:(self setAnswerBytes)) = set]	! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 6/2/2011 23:50'!testReadSharedRefrences1	"self debug: #testReadSharedRefrences1"	| bytes reader obj inst1 inst2 expected  |	bytes := self sharedReferenceAnswerBytes.	reader := StompReader onBytes: bytes.	obj := reader next.		inst1 := StompMockVariableClass new: 3.	inst1 at: 1 put: 1.	inst1 at: 2 put: 'two'.	inst1 at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).		inst2 := StompMockMixedClass new: 3.	inst2 at: 1 put: 1.	inst2 at: 2 put: 'two'.	inst2 at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).	inst2 instVar1: #(true false).	inst2 instVar2: #(nil #()).		expected := Array with: inst1 with: inst2 with: inst1 with: inst2.		self should: [obj = expected].			! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:07'!testReadString	"self debug: #testReadString"	| str1 |	str1 := 'Hi, I''m String-object'.	self should: [(Object fromStomp:(self stringAnswerBytes)) = str1].		! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:06'!testReadTime	"self debug: #testReadTime"		| bytes inst |	bytes := self timeAnswerBytes.	inst := Object fromStomp: bytes.		self should: [inst class = Time].	self should: [inst = (Time fromSeconds: 84072)].	! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/10/2011 12:50'!testReadTimestamp	"self debug: #testReadTimestamp"		| timestamp |	timestamp := StompPortableUtil default testFixturesClass timestamp1.	self should: [(Object fromStomp: (self timestampAnswerBytes)) = timestamp]	! !!StompReaderTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 16:14'!testReadUndefinedObject	"self debug: #testReadUndefinedObject"	self should: [(Object fromStomp:(#[192])) = nil].		! !StompTestCase subclass: #StompShapeChangerTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompShapeChangerTestCase methodsFor: 'fixtures' stamp: 'mu 5/26/2011 23:47'!fixedClassOLDAnswerArray1	^  #[147 161 2 129 17 218 0 22 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 79 76 68 129 149 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 168 105 110 115 116 86 97 114 51 168 105 110 115 116 86 97 114 52 168 105 110 115 116 86 97 114 53 149 1 146 161 5 163 116 119 111 203 64 10 102 102 102 102 102 102 194 146 161 4 164 70 73 86 69]! !!StompShapeChangerTestCase methodsFor: 'fixtures' stamp: 'mu 5/27/2011 00:06'!fixedClassOLDAnswerArray2	 ^ #[147 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 129 149 168 105 110 115 116 86 97 114 49 171 105 110 115 116 86 97 114 50 79 76 68 168 105 110 115 116 86 97 114 51 168 105 110 115 116 86 97 114 52 168 105 110 115 116 86 97 114 54 149 1 146 161 5 170 114 101 110 97 109 101 100 84 119 111 203 64 10 102 102 102 102 102 102 194 146 161 4 167 65 68 68 69 68 45 54]! !!StompShapeChangerTestCase methodsFor: 'fixtures' stamp: 'mu 6/6/2011 13:03'!mockPersonAnswerArray1	 ^  #[147 161 2 129 17 218 0 18 83 116 111 109 112 77 111 99 107 80 101 114 115 111 110 79 76 68 129 147 168 102 117 108 108 78 97 109 101 168 114 101 113 117 101 115 116 115 168 112 97 114 116 110 101 114 115 147 146 161 4 161 65 146 147 161 2 129 17 218 0 16 83 116 111 109 112 77 111 99 107 82 101 113 117 101 115 116 129 146 162 105 100 165 111 119 110 101 114 146 1 146 161 3 0 147 161 2 1 147 1 2 147 161 2 0 148 0 146 161 4 161 66 192 145 146 161 3 0 192]! !!StompShapeChangerTestCase methodsFor: 'fixtures' stamp: 'mu 6/6/2011 12:56'!renamedComplexReadAnswerArray1	 ^  #[147 147 161 2 129 17 218 0 30 83 116 111 109 112 77 111 99 107 83 104 97 112 101 67 104 97 110 103 101 100 79 98 106 101 99 116 79 76 68 129 146 172 111 108 100 78 97 109 101 100 86 97 114 49 172 111 114 105 103 105 110 97 108 65 116 116 49 146 1 3 147 161 2 0 147 0 11 33 146 161 3 1]! !!StompShapeChangerTestCase methodsFor: 'fixtures' stamp: 'mu 6/6/2011 12:29'!renamedComplexReadAnswerArray2	 ^  #[148 147 161 2 129 17 218 0 30 83 116 111 109 112 77 111 99 107 83 104 97 112 101 67 104 97 110 103 101 100 79 98 106 101 99 116 79 76 68 129 146 172 111 108 100 78 97 109 101 100 86 97 114 49 172 111 114 105 103 105 110 97 108 65 116 116 49 146 1 3 147 161 2 0 147 0 11 33 146 161 3 1 146 161 4 164 104 101 114 101]! !!StompShapeChangerTestCase methodsFor: 'fixtures' stamp: 'mu 6/6/2011 12:54'!renamedComplexReadAnswerArray3	 ^ #[147 147 161 2 129 17 218 0 30 83 116 111 109 112 77 111 99 107 83 104 97 112 101 67 104 97 110 103 101 100 79 98 106 101 99 116 79 76 68 129 146 172 111 108 100 78 97 109 101 100 86 97 114 49 172 111 114 105 103 105 110 97 108 65 116 116 49 146 1 3 147 161 2 0 147 0 11 33 146 161 3 1]! !!StompShapeChangerTestCase methodsFor: 'fixtures' stamp: 'mu 6/6/2011 12:18'!renamedComplexReadAnswerArray4	 ^  #[148 147 161 2 129 17 218 0 30 83 116 111 109 112 77 111 99 107 83 104 97 112 101 67 104 97 110 103 101 100 79 98 106 101 99 116 79 76 68 129 147 172 111 108 100 78 97 109 101 100 86 97 114 49 172 111 114 105 103 105 110 97 108 65 116 116 49 167 111 108 100 86 97 114 50 147 1 3 192 147 161 2 0 148 0 11 33 44 146 161 3 1 146 161 4 164 104 101 114 101]! !!StompShapeChangerTestCase methodsFor: 'fixtures' stamp: 'mu 6/6/2011 11:34'!renamedNewFailedAnswerArray1	 ^  #[147 147 161 2 129 17 218 0 30 83 116 111 109 112 77 111 99 107 70 105 120 101 100 65 108 116 101 114 110 97 116 105 118 101 67 108 97 115 115 129 147 164 97 116 116 49 164 97 116 116 50 169 97 116 116 51 66 108 111 99 107 147 1 2 192 147 161 2 0 148 0 3 4 192 146 161 3 1]! !!StompShapeChangerTestCase methodsFor: 'fixtures' stamp: 'mu 6/6/2011 12:22'!renamedReadFailedAnswerArray1	 ^ #[147 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 129 149 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 168 105 110 115 116 86 97 114 51 168 105 110 115 116 86 97 114 52 168 105 110 115 116 86 97 114 53 149 146 161 4 165 116 101 115 116 49 147 161 2 129 17 218 0 23 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 50 79 76 68 129 149 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 168 105 110 115 116 86 97 114 51 168 105 110 115 116 86 97 114 52 168 105 110 115 116 86 97 114 53 149 146 161 4 165 116 101 115 116 50 192 192 192 192 146 161 4 165 116 101 115 116 51 149 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 77 105 120 101 100 67 108 97 115 115 2 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 192 192 146 146 161 4 165 116 101 115 116 52 147 161 2 1 150 1 146 161 4 165 116 101 115 116 53 192 192 192 192 192]! !!StompShapeChangerTestCase methodsFor: 'testing' stamp: 'mu 5/11/2011 11:38'!testBlockRenamedComplexShapeChangerRead	"self debug: #testBlockRenamedComplexShapeChangerRead"	| bytes arr obj1 obj2 obj3 |	bytes := self renamedComplexReadAnswerArray3.	arr := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockShapeChangedObjectOLD for: StompMockShapeChangedObject.		ctx registerShapeChangerRenameBy: [:target :oldName :value |			oldName = 'oldNamedVar1' ifTrue: [target renamedAtt1: value].		] initializeBy: [:target |			target addedAtt1: 22222.		] for: StompMockShapeChangedObject.	].		self should: [arr class = Array].	self should: [arr size = 3].	obj1 := arr at: 1.	self should: [obj1 renamedAtt1 = 1].	self should: [obj1 addedAtt1 = 22222].	self should: [obj1 originalAtt1 = 3].	obj2 := arr at: 2.	self should: [obj2 renamedAtt1 = 11].	self should: [obj2 addedAtt1 = 22222].	self should: [obj2 originalAtt1 = 33].	obj3 := arr at: 3.	self should: [obj3 = obj1].! !!StompShapeChangerTestCase methodsFor: 'testing' stamp: 'mu 6/3/2011 10:37'!testBlockShapeChangedRead	"self debug: #testBlockShapeChangedRead"	| bytes inst expected |	bytes := self fixedClassOLDAnswerArray2.	inst := Object fromStomp: bytes setting: [:ctx |		ctx registerShapeChangerRenameBy: [:target :oldName :value | 			oldName = 'instVar2OLD' ifTrue: [target instVar2: value].		] initializeBy: [:target | 			target instVar5: 'FIVE'		] for: StompMockFixedClass.	].		expected := StompMockFixedClass new.	expected instVar1: 1.	expected instVar2: #renamedTwo.	expected instVar3: (StompPortableUtil default testFixturesClass double3dot3).	expected instVar4: false.	expected instVar5: 'FIVE'.		self should: [inst equals: expected].! !!StompShapeChangerTestCase methodsFor: 'testing' stamp: 'mu 5/11/2011 10:44'!testNewFailedRead	"self debug: #testNewFailedRead"	| bytes arr obj1 obj2 obj3 |	bytes := self renamedNewFailedAnswerArray1.	arr := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockFixedNewFailedClass for: StompMockFixedAlternativeClass.	].	self should: [arr class = Array].	self should: [arr size = 3].	obj1 := arr at: 1.	self should: [obj1 class = StompMockFixedAlternativeClass].	self should: [obj1 att1 = 1].	self should: [obj1 att2 = 2].	self should: [obj1 att3Block notNil].	obj2 := arr at: 2.	self should: [obj2 class = StompMockFixedAlternativeClass].	self should: [obj2 att1 = 3].	self should: [obj2 att2 = 4].	self should: [obj2 att3Block notNil].	obj3 := arr at: 3.	self should: [obj3 = obj1].! !!StompShapeChangerTestCase methodsFor: 'testing' stamp: 'mu 5/11/2011 11:28'!testRenamedComplexRead	"self debug: #testRenamedComplexRead"	| bytes arr obj1 obj2 obj3 |	bytes := self renamedComplexReadAnswerArray1.	arr := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockShapeChangedObjectOLD for: StompMockShapeChangedObject.	].		self should: [arr class = Array].	self should: [arr size = 3].	obj1 := arr at: 1.	self should: [obj1 renamedAtt1 = 1].	self should: [obj1 addedAtt1 = 2].	self should: [obj1 originalAtt1 = 3].	obj2 := arr at: 2.	self should: [obj2 renamedAtt1 = 11].	self should: [obj2 addedAtt1 = 2].	self should: [obj2 originalAtt1 = 33].	obj3 := arr at: 3.	self should: [obj3 = obj1].! !!StompShapeChangerTestCase methodsFor: 'testing' stamp: 'mu 5/11/2011 11:38'!testRenamedComplexReadFailed	"self debug: #testRenamedComplexReadFailed"	| bytes arr |	bytes := self renamedComplexReadAnswerArray2.	arr := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockShapeChangedObjectFAILED for: StompMockShapeChangedObject.	].		self should: [arr class = Array].	self should: [arr size = 4].	self should: [arr = #(nil nil nil 'here')].! !!StompShapeChangerTestCase methodsFor: 'testing' stamp: 'mu 5/11/2011 11:39'!testRenamedComplexShapeChangerRead	"self debug: #testRenamedComplexShapeChangerRead"	| bytes arr obj1 obj2 obj3 |	bytes := self renamedComplexReadAnswerArray3.	arr := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockShapeChangedObjectOLD shapeChanger: StompMockShapeChangerForRenamedComplexRead for: StompMockShapeChangedObject.	].		self should: [arr class = Array].	self should: [arr size = 3].	obj1 := arr at: 1.	self should: [obj1 renamedAtt1 = 1].	self should: [obj1 addedAtt1 = 22222].	self should: [obj1 originalAtt1 = 3].	obj2 := arr at: 2.	self should: [obj2 renamedAtt1 = 11].	self should: [obj2 addedAtt1 = 22222].	self should: [obj2 originalAtt1 = 33].	obj3 := arr at: 3.	self should: [obj3 = obj1].! !!StompShapeChangerTestCase methodsFor: 'testing' stamp: 'mu 5/11/2011 11:50'!testRenamedComplexShapeChangerReadFailed	"self debug: #testRenamedComplexShapeChangerReadFailed"	| bytes arr |	bytes := self renamedComplexReadAnswerArray4.	arr := Object fromStomp: bytes setting: [:ctx |		ctx registerShapeChanger: StompMockShapeChangerForRenamedComplexRead for: StompMockFixedClass.	].		self should: [arr class = Array].	self should: [arr size = 4].	self should: [arr = #(nil nil nil 'here')].! !!StompShapeChangerTestCase methodsFor: 'testing' stamp: 'mu 6/3/2011 10:38'!testRenamedRead	"self debug: #testRenamedRead"	| bytes inst expected |	bytes := self fixedClassOLDAnswerArray1.	inst := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockFixedClassOLD for: StompMockFixedClass.	].		expected := StompMockFixedClass new.	expected instVar1: 1.	expected instVar2: #two.	expected instVar3: (StompPortableUtil default testFixturesClass double3dot3).	expected instVar4: false.	expected instVar5: 'FIVE'.		self should: [inst equals: expected].! !!StompShapeChangerTestCase methodsFor: 'testing' stamp: 'mu 5/11/2011 10:03'!testRenamedReadFailed	"self debug: #testRenamedReadFailed"	| bytes inst |	bytes := self renamedReadFailedAnswerArray1.	"By default, unresolved class's instance will be nil"	inst := Object fromStomp: bytes.	self should: [inst class = StompMockFixedClass].	self should: [inst instVar1 = 'test1'].	self should: [inst instVar2 isNil].	self should: [inst instVar3 = 'test3'].	self should: [inst instVar4 class = StompMockMixedClass].	self should: [(inst instVar4 at: 1) = 'test4'].	self should: [(inst instVar4 at: 2) isNil].	self should: [inst instVar5 isNil].		"Override the behavior by context"	inst := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockFixedClass2OLD for: StompMockFixedClass2.	].	self should: [inst class = StompMockFixedClass].	self should: [inst instVar1 = 'test1'].	self should: [inst instVar2 class = StompMockFixedClass2].	self should: [inst instVar2 instVar1= 'test2'].	self should: [inst instVar3 = 'test3'].	self should: [inst instVar4 class = StompMockMixedClass].	self should: [(inst instVar4 at: 1) = 'test4'].	self should: [(inst instVar4 at: 2) class = StompMockFixedClass2].	self should: [(inst instVar4 at: 2) instVar1 = 'test5'].	self should: [inst instVar5 isNil].		"Or you can use exception handling"	inst := [Object fromStomp: bytes ] on: StompClassNotFound do: [:ex |			ex resume: (ex className == #StompMockFixedClass2OLD ifTrue: [ StompMockFixedClass2] ifFalse: [ex unresolvedClass])].	self should: [inst class = StompMockFixedClass].	self should: [inst instVar1 = 'test1'].	self should: [inst instVar2 class = StompMockFixedClass2].	self should: [inst instVar2 instVar1= 'test2'].	self should: [inst instVar3 = 'test3'].	self should: [inst instVar4 class = StompMockMixedClass].	self should: [(inst instVar4 at: 1) = 'test4'].	self should: [(inst instVar4 at: 2) class = StompMockFixedClass2].	self should: [(inst instVar4 at: 2) instVar1 = 'test5'].	self should: [inst instVar5 isNil].! !!StompShapeChangerTestCase methodsFor: 'testing' stamp: 'mu 6/3/2011 10:38'!testRenamedShapeChangedRead	"self debug: #testRenamedShapeChangedRead"	| bytes inst expected |	bytes := self fixedClassOLDAnswerArray2.	inst := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockFixedClassOLD shapeChanger: StompMockShapeChanger for: StompMockFixedClass.	].		expected := StompMockFixedClass new.	expected instVar1: 1.	expected instVar2: #renamedTwo.	expected instVar3: (StompPortableUtil default testFixturesClass double3dot3).	expected instVar4: false.	expected instVar5: 'FIVE'.		self should: [inst equals: expected].! !!StompShapeChangerTestCase methodsFor: 'testing' stamp: 'mu 6/3/2011 10:39'!testShapeChangedRead	"self debug: #testShapeChangedRead"	| bytes inst expected |	bytes := self fixedClassOLDAnswerArray2.	inst := Object fromStomp: bytes setting: [:ctx |		ctx registerShapeChanger: StompMockShapeChanger for: StompMockFixedClass.	].		expected := StompMockFixedClass new.	expected instVar1: 1.	expected instVar2: #renamedTwo.	expected instVar3: (StompPortableUtil default testFixturesClass double3dot3).	expected instVar4: false.	expected instVar5: 'FIVE'.		self should: [inst equals: expected].! !!StompShapeChangerTestCase methodsFor: 'testing' stamp: 'mu 5/11/2011 11:12'!testShapeChangedReadCircularReference	"self debug: #testShapeChangedReadCircularReference"	| bytes obj |	bytes := self mockPersonAnswerArray1.	obj := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockPersonOLD shapeChanger: StompMockPersonShapeChanger for: StompMockPerson.	]. 	self should: [obj class = StompMockPerson].	self should: [obj name = 'A'].	self should: [obj requests size = 2].	self should: [(obj requests detect: [:each | each id = 1]) owner = obj].	self should: [(obj requests detect: [:each | each id = 2]) owner name = 'B'].	self should: [(obj requests detect: [:each | each id = 2]) owner partners size = 1].	self should: [((obj requests detect: [:each | each id = 2]) owner partners at: 1) = obj].! !StompTestCase subclass: #StompWriterTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StompTest-Core'!!StompWriterTestCase commentStamp: 'mu 1/5/2011 14:27' prior: 0!self suite run!!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 6/5/2011 23:59'!testWriteBag	"self debug: #testWriteBag"	| bag actual expected |	bag := Bag new.	bag add: 10.	bag add: 20.	bag add: 30.	bag add: 30.	expected := self bagAnswerBytes.		actual := bag toStomp.		self should: [actual size = 9].	self should: [(actual copyFrom: 1 to: 5) = (expected copyFrom: 1 to: 5)].	self should: [(actual copyFrom: 6 to: 9) asSortedCollection = (expected copyFrom: 6 to: 9) asSortedCollection]! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 15:48'!testWriteBasicArray	"self debug: #testWriteBasicArray"	| data wstr bytes |	data := #(1 2 3 #('Hello' 2 3)).	wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.		self should: [bytes = self basicArrayAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 15:49'!testWriteBasicBitsClass	"self debug: #testWriteBasicBitsClass"	| data wstr bytes |	data := StompMockByteArray new: 3.	data at: 1 put: 0.	data at: 2 put: 127.	data at: 3 put: 255.	wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.		self should: [bytes = self basicBitsClassAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 15:50'!testWriteBasicFixedClass	"self debug: #testWriteBasicFixedClass"	| data wstr bytes |	data := StompMockFixedClass new.	data instVar1: 1.	data instVar2: #two.	data instVar3: 3.3.	data instVar4: false.	data instVar5: 'FIVE'.	wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.		self should: [bytes = self basicFixedClassAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 6/2/2011 23:36'!testWriteBasicMixedClass	"self debug: #testWriteBasicMixedClass"	| data wstr bytes |	data := StompMockMixedClass new: 3.	data at: 1 put: 1.	data at: 2 put: 'two'.	data at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).	data instVar1: #(true false).	data instVar2: #(nil #()).	wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.		self should: [bytes = self basicMixedClassAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 6/2/2011 23:36'!testWriteBasicVariableClass	"self debug: #testWriteBasicVariableClass"	| data wstr bytes |	data := StompMockVariableClass new: 3.	data at: 1 put: 1.	data at: 2 put: 'two'.	data at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).		wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.		self should: [bytes = self basicVariableClassAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 00:05'!testWriteBoolean	"self debug: #testWriteBoolean"	self should: [true toStomp =  #[195]].	self should: [false toStomp =  #[194]]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 00:05'!testWriteByteArray	"self debug: #testWriteByteArray"	| byteArray |	byteArray := (ByteArray with: 10 with: 20 with: 30).	self should: [byteArray toStomp = #[163 10 20 30]].			! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 7/15/2011 23:57'!testWriteCharacter	"self debug: #testWriteCharacter"	| char1 char2 |	char1 := $A.		self should: [char1 toStomp =  #[147 161 2 253 65]].	char2 := (StompPortableUtil default characterFromUnicode: 12354). "Japanese Hiragana 'A' "		self should: [char2 toStomp =  #[147 161 2 253 205 48 66]].			! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 6/2/2011 23:36'!testWriteCircularRefrences1	"self debug: #testWriteCircularRefrences1"	| inst1 inst2 data wstr bytes |	inst1 := StompMockVariableClass new: 3.	inst1 at: 1 put: 1.	inst1 at: 2 put: 'two'.	inst1 at: 3 put: inst1.		inst2 := StompMockMixedClass new: 3.	inst2 at: 1 put: 1.	inst2 at: 2 put: 'two'.	inst2 at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).	inst2 instVar1: inst1.	inst2 instVar2: inst2.		data := Array with: inst1 with: inst2 with: inst1 with: inst2.		wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.	self should: [bytes = self circularRefrencesAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 23:59'!testWriteClass	"self debug: #testWriteClass"	| cls bytes |	cls := StompMockObjectWithCache.	cls att1: 11.	cls att2: 22.	bytes := cls toStomp.	self should: [bytes = self classAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/14/2011 12:31'!testWriteClassNameAndIds	"self debug: #testWriteClassNameAndIds"	| data1 data2 data3 data4 wstr bytes  data |	data1 := StompMockFixedClass new.	data1 instVar1: 1.	data1 instVar2: #one.		data2 := StompMockFixedClass new.	data2 instVar1: 2.	data2 instVar2: #two.		data3 := StompMockMixedClass new.	data3 instVar1: 3.	data3 instVar2: #three.		data4 := StompMockMixedClass new.	data4 instVar1: 4.	data4 instVar2: #four.		data := Array with: data1 with: data2 with: data3 with: data4.		wstr := StompWriter onBytes: ByteArray new.	wstr settings suppressNilWrite: false.	wstr nextPut: data.	bytes := wstr contents. 			self should: [bytes = self classNameAndIdsAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/12/2011 22:04'!testWriteClassNameAndIdsSuppressNilWrites	"self debug: #testWriteClassNameAndIdsSuppressNilWrites"	| data1 data2 data3 data4 wstr bytes  data |	data1 := StompMockFixedClass new.	data1 instVar1: 1.	data1 instVar2: #one.		data2 := StompMockFixedClass new.	data2 instVar1: 2.	data2 instVar2: #two.		data3 := StompMockMixedClass new.	data3 instVar1: 3.	data3 instVar2: #three.		data4 := StompMockMixedClass new.	data4 instVar1: 4.	data4 instVar2: #four.		data := Array with: data1 with: data2 with: data3 with: data4.		wstr := StompWriter onBytes: ByteArray new.	wstr settings suppressNilWrite: true.	wstr nextPut: data.	bytes := wstr contents. 			self should: [bytes = self classNameAndIdsSuppressNilWritesAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 15:53'!testWriteColor	"self debug: #testWriteColor"	| color1 bytes1 color2 bytes2 |	color1 := StompPortableUtil default testFixturesClass blueColor.	bytes1 := color1 toStomp.	self should: [bytes1 = self colorAnswerBytes1].		color2 := StompPortableUtil default testFixturesClass yellowColor.	bytes2 := color2 toStomp.	self should: [bytes2 = self colorAnswerBytes2]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/28/2011 22:39'!testWriteCompositeDictionary	"self debug: #testWriteCompositeDictionary"	| childDic dic bytes rawDic rawChildDic |	childDic := Dictionary new.	childDic at: #child1 put: 'abcde'.	dic := Dictionary new.	dic at: #parent1 put: 'sample string.'.	dic at: #parent2 put: 100.	dic at: #parent3 put: #(10 20 30 ).	dic at: #parent4 put: childDic.	bytes := dic toStomp.	rawDic := Object fromMessagePack: bytes.	self should: [rawDic size = 4].	self should: [(rawDic at: #(#[5] #[112 97 114 101 110 116 49])) = #(#[4] #[115 97 109 112 108 101 32 115 116 114 105 110 103 46])].	self should: [(rawDic at: #(#[5] #[112 97 114 101 110 116 50])) = 100].	self should: [(rawDic at: #(#[5] #[112 97 114 101 110 116 51])) = #(10 20 30)].	rawChildDic := rawDic at: #(#[5] #[112 97 114 101 110 116 52]).	self should: [(rawChildDic at: #(#[5] #[99 104 105 108 100 49])) = #(#[4] #[97 98 99 100 101])].	! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 15:54'!testWriteDate	"self debug: #testWriteDate"	| date bytes |	date := Date fromDays: 37023.	bytes := date toStomp.	self should: [bytes = self dateAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/28/2011 22:33'!testWriteDictionary	"self debug: #testWriteDictionary"	| dic bytes rawDic |	dic := Dictionary new.	dic at: #key1 put: 'value1'.	dic at: #key2 put: 'value2'.	dic at: #key3 put: 'value3'.		bytes := dic toStomp.	rawDic := Object fromMessagePack: bytes.	self should: [rawDic size = 3].	self should: [(rawDic at: #(#[5] #[107 101 121 49])) = #(#[4] #[118 97 108 117 101 49])].	self should: [(rawDic at: #(#[5] #[107 101 121 50])) = #(#[4] #[118 97 108 117 101 50])].	self should: [(rawDic at: #(#[5] #[107 101 121 51])) = #(#[4] #[118 97 108 117 101 51])].	! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 6/1/2011 23:28'!testWriteDuration	"self debug: #testWriteDuration"	| duration bytes |	duration := 123 seconds.	bytes := duration toStomp.	self should: [bytes = self durationAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 6/2/2011 23:37'!testWriteFixedClassWithNilValues	"self debug: #testWriteFixedClassWithNilValues"	| data wstr bytes |	data := StompMockFixedClass new.	data instVar1: 1.	data instVar2: nil.	data instVar3: (StompPortableUtil default testFixturesClass double3dot3).	data instVar4: nil.	data instVar5: 'FIVE'.	wstr := StompWriter onBytes: ByteArray new.	wstr settings suppressNilWrite: true.	wstr nextPut: data.	bytes := wstr contents.		self should: [bytes = self fixedClassWithNilValuesAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 15:55'!testWriteFraction	"self debug: #testWriteFraction"	| fra bytes |	fra := 3 / 4.		bytes := fra toStomp.	self should: [bytes = self fractionAnswerBytes]	! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 15:56'!testWriteInterval	"self debug: #testWriteInterval"	| interval bytes |	interval := 1 to: 10 by: 3.		bytes := interval toStomp.	self should: [bytes = self intervalAnswerBytes]	! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 15:56'!testWriteMixedClassNoVariableData	"self debug: #testWriteMixedClassNoVariableData"	| data wstr bytes |	data := StompMockMixedClass new.	data instVar1: #(true false).	data instVar2: #(nil #()).	wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.		self should: [bytes = self mixedClassNoVariableDataAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 6/3/2011 11:51'!testWriteNumber	"self debug: #testWriteNumber"	self should: [1 toStomp = #[1]].	self should: [1.2 toStomp = self floatingPointAnswerBytes1].	self should: [StompPortableUtil default testFixturesClass double1234567890dot123456789 toStomp = self floatingPointAnswerBytes2]! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 15:57'!testWriteOrdredCollection	"self debug: #testWriteOrdredCollection"	| ord bytes |	ord := OrderedCollection new.	ord add: 10.	ord add: 20.	ord add: 30.	bytes := ord toStomp.	self should: [bytes =  self ordredCollectionAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 15:58'!testWriteRectangle	"self debug: #testWriteRectangle"	| rect bytes |	rect := (1@1 corner: 3@4).		bytes := rect toStomp.	self should: [bytes = self rectangleAnswerBytes]	! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/10/2011 12:04'!testWriteRecursiveArray	"self debug: #testWriteRecursiveArray"	| arr bytes |	arr := Array new: 3.	arr at: 1 put: 10.	arr at: 2 put: 20.	arr at: 3 put: arr.	bytes := arr toStomp.	self should: [bytes = self recursiveArrayAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 15:58'!testWriteRunArray	"self debug: #testWriteRunArray"	| arr bytes |	arr := RunArray runs: #(1 2 1) values: #(1 2 3).	bytes := arr toStomp.	self should: [bytes = self runArrayAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 6/6/2011 11:00'!testWriteSet	"self debug: #testWriteSet"	| set expected actual |	set := Set new.	set add: 10.	set add: 20.	set add: 30.	set add: 30.	expected := self setAnswerBytes.		actual := set toStomp.		self should: [actual size = 8].	self should: [(actual copyFrom: 1 to: 5) = (expected copyFrom: 1 to: 5)].	self should: [(actual copyFrom: 6 to: 8) asSortedCollection = (expected copyFrom: 6 to: 8) asSortedCollection]		! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 6/2/2011 23:38'!testWriteSharedRefrences1	"self debug: #testWriteSharedRefrences1"	| inst1 inst2 data wstr bytes |	inst1 := StompMockVariableClass new: 3.	inst1 at: 1 put: 1.	inst1 at: 2 put: 'two'.	inst1 at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).		inst2 := StompMockMixedClass new: 3.	inst2 at: 1 put: 1.	inst2 at: 2 put: 'two'.	inst2 at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).	inst2 instVar1: #(true false).	inst2 instVar2: #(nil #()).		data := Array with: inst1 with: inst2 with: inst1 with: inst2.		wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.	self should: [bytes = self sharedReferenceAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 15:58'!testWriteString	"self debug: #testWriteString"	| str1 |	str1 := 'Hi, I''m String-object'.	self should: [str1 toStomp = self stringAnswerBytes].				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 15:59'!testWriteSymbol	"self debug: #testWriteSymbol"	| symbol1 |	symbol1 := #abcdefg.	self should: [symbol1 toStomp = self symbolAnswerBytes].				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/9/2011 15:59'!testWriteTime	"self debug: #testWriteTime"	| inst bytes |	inst := Time fromSeconds: 84072.	bytes := inst toStomp.	self should: [bytes = self timeAnswerBytes]				! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/10/2011 12:49'!testWriteTimestamp	"self debug: #testWriteTimestamp"	| bytes timestamp |	timestamp := StompPortableUtil default testFixturesClass timestamp1.	bytes := timestamp toStomp.	self should: [bytes = self timestampAnswerBytes]	! !!StompWriterTestCase methodsFor: 'tests' stamp: 'mu 5/7/2011 22:12'!testWriteUndefinedObject	"self debug: #testWriteUndefinedObject"	self should: [nil toStomp = #[192]].		! !