StompPopularClassMap subclass: #StompSqPopularClassMap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Stomp-Squeak-Core'!!StompSqPopularClassMap methodsFor: 'factory' stamp: 'mu 5/25/2011 00:18'!fixedPointClass	^ self classNamed: #ScaledDecimal! !!StompSqPopularClassMap methodsFor: 'factory' stamp: 'mu 5/10/2011 12:38'!timestampClass	^ self classNamed: #TimeStamp! !!StompSqPopularClassMap methodsFor: 'factory' stamp: 'mu 6/3/2011 21:47'!uint16ArrayClass	^ nil! !!StompSqPopularClassMap methodsFor: 'factory' stamp: 'mu 6/3/2011 21:46'!uint32ArrayClass	^ self classNamed: #WordArray! !StompPortableUtil subclass: #StompSqPortableUtil	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Stomp-Squeak-Core'!!StompSqPortableUtil methodsFor: 'actions' stamp: 'mu 4/20/2011 00:01'!bytes: rawBytes intoOf: bitsClass	"override"	| inst |	bitsClass isWords ifTrue: [ | hackBlt |		inst := bitsClass basicNew: rawBytes size / 4.		hackBlt := (BitBlt toForm: (Form new hackBits: inst))				sourceForm: (Form new hackBits: rawBytes);				width: 4; height: inst size; combinationRule: 3. "Form over"		Smalltalk isLittleEndian ifTrue: [hackBlt sourceForm swapEndianness].		hackBlt copyBits.						^inst	] ifFalse:[		inst := bitsClass new: rawBytes size.		inst replaceFrom: 1 to: inst size with: rawBytes startingAt: 1.		^inst	].	! !!StompSqPortableUtil methodsFor: 'actions' stamp: 'mu 1/13/2011 00:56'!bytesFrom: bitsObject 	"override"	bitsObject class isWords		ifTrue: [^ ByteArray streamContents: [:str | str nextWordsPutAll: bitsObject]].	^ super bytesFrom: bitsObject! !!StompSqPortableUtil methodsFor: 'actions' stamp: 'mu 6/1/2011 11:36'!instVarIndexOf: aClass for: varName 	^ aClass		instVarIndexFor: varName asString		ifAbsent: [0]! !!StompSqPortableUtil methodsFor: 'actions' stamp: 'mu 6/1/2011 11:33'!instVarNamed: varName put: value in: anObject	"Note that when varName is invalid, just silently ignore"	| index |	index := anObject class						instVarIndexFor: varName asString						ifAbsent: [^self].	anObject instVarAt: index put: value			! !!StompSqPortableUtil methodsFor: 'actions' stamp: 'mu 6/3/2011 10:28'!nextAvailable: size from: stream	^stream next: size! !!StompSqPortableUtil methodsFor: 'actions' stamp: 'mu 2/1/2011 23:07'!useEnvironmentByDefault	^false! !!StompSqPortableUtil methodsFor: 'converting' stamp: 'mu 5/6/2011 23:14'!bytesFromString: aString	aString isWideString ifTrue: [^aString squeakToUtf8 asByteArray].	^aString asByteArray! !!StompSqPortableUtil methodsFor: 'converting' stamp: 'mu 3/9/2011 23:44'!characterFromUnicode: anInteger	^Unicode value: anInteger! !!StompSqPortableUtil methodsFor: 'converting' stamp: 'mu 5/8/2011 14:53'!colorFromRgbArray: rgbArray	^Color r: rgbArray first asNumber g: rgbArray second asNumber b: rgbArray third asNumber! !!StompSqPortableUtil methodsFor: 'converting' stamp: 'mu 5/10/2011 14:35'!dateAndTimeFromNanoseconds: nanoseconds	^ DateAndTime epoch + (Duration nanoSeconds: nanoseconds)! !!StompSqPortableUtil methodsFor: 'converting' stamp: 'mu 6/1/2011 23:26'!durationFromNanoseconds: nanoseconds	^Duration nanoSeconds: nanoseconds! !!StompSqPortableUtil methodsFor: 'converting' stamp: 'mu 6/1/2011 23:37'!nanosecondsFromDateAndTime: dateAndTime	"Answer the number of nanoseconds since January 1, 1901."	^dateAndTime asSeconds * 1000000000 + dateAndTime nanoSecond! !!StompSqPortableUtil methodsFor: 'converting' stamp: 'mu 6/1/2011 23:36'!nanosecondsFromDuration: duration	^ duration asNanoSeconds! !!StompSqPortableUtil methodsFor: 'converting' stamp: 'mu 5/14/2011 12:13'!stringFromBytes: aByteArray	| str |	str := aByteArray asString.	^[str utf8ToSqueak] on: Error do: [:ex | ^str]! !!StompSqPortableUtil methodsFor: 'converting' stamp: 'mu 5/10/2011 14:36'!timestampFromNanoseconds: nanoseconds	"^ Timestamp fromNanoseconds: nanoseconds"	^ TimeStamp epoch + (Duration nanoSeconds: nanoseconds)! !!StompSqPortableUtil methodsFor: 'converting' stamp: 'mu 3/9/2011 23:42'!unicodeFromCharacter: aCharacter	^aCharacter asUnicode! !!StompSqPortableUtil methodsFor: 'testing' stamp: 'mu 5/30/2011 00:48'!isWideString: aString	^aString isWideString! !!StompSqPortableUtil methodsFor: 'testing' stamp: 'mu 5/30/2011 00:48'!isWideSymbol: aSymbol	^aSymbol isWideString! !!StompSqPortableUtil methodsFor: 'factory' stamp: 'mu 5/7/2011 17:26'!popularClassMap	"override"	^StompSqPopularClassMap default! !!StompSqPortableUtil methodsFor: '*StompTest-Squeak-Core-factory' stamp: 'mu 5/8/2011 14:37'!testFixturesClass	^ StompSqFixtures! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StompSqPortableUtil class	instanceVariableNames: ''!!StompSqPortableUtil class methodsFor: 'class initialization' stamp: 'mu 5/28/2011 22:01'!initialize	"StompSqPortableUtil initialize"	| klsName |	super initialize.	klsName := ('squeak*' match: SystemVersion current version asLowercase) ifTrue: [#StompSqPortableUtil] ifFalse: [#StompPharoPortableUtil].	Smalltalk at: klsName ifPresent: [:p | StompPortableUtil dialectSpecificClass: p].	! !StompSqPortableUtil initialize!